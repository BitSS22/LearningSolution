#include <iostream>

int main()
{
	int a = 0;

	int* ptr = &a; // ok.
	
	// 문법적인 의미는 아주 간단하다.
	
	// * -> 주소를 담는 변수라는 선언.
	// x86은 32bit, x64는 64bit의 크기를 가진다.
	// 포인터라는 사실 자체가 자료형의 타입이다. 앞에 어떤 타입이 오던 포인터 변수 자체와는 아무런 관련 없다.
	
	// * 앞의 자료형 -> 주소에 접근했을 때 데이터를 어떻게 해석할 것인가?
	// int* -> 주소로 접근 했을 때, int로 해석하겠다 == 4바이트 크기, 정수형으로 데이터를 읽겠다.

	// 즉 int* ptr = &a;의 뜻은 다음과 같다.
	// ptr이라는 변수를 선언한다. 변수는 주소를 저장할 수 있는 8바이트 정수 형태의 변수다.
	// 이 변수는 a가 가지고 있는 메모리의 주소값으로 초기화 할 것이다.
	// 이 변수를 통해 주소값으로 접근 할 경우, 내가 들고 있는 주소값에 접근 한 후, int 타입으로 메모리를 해석하겠다. -> sizeof(int)크기에, 정수 형태로.

	*ptr = 1; // ok.
	// 포인터 변수가 들고 있는 주소값에 접근하겠다. 이 때, ptr의 타입(int)에 따라 주소를 해석한다.
	// 즉 현재 int로 해석 됐으므로 sizeof(int) 크기의 메모리를 정수형으로 해석하고, 그 메모리 위치에 1을 대입하겠다.

	char* chaPtr = reinterpret_cast<char*>(&a); // ok. 그러나 위험 요소가 굉장히 많은 재 해석 캐스팅.
	*chaPtr = 123; // 지금 당장은 문제 없다..
	// a가 저장 된 주소값은 결국 같다. 그리고 a는 int니, 현재 환경에서 4바이트 크기를 가진다.
	// 그 중, 같은 주소로 접근해 1바이트 정수로 읽겠다고 한다. 그러니 일단 문제는 없긴 하다..

	void* voidPtr = &a; // ok.
	// *voidPtr = 3; // error.
	// 따라서 void*라는 타입이 가지는 의미도 어렵지 않다.
	// 주소값을 저장하는 변수지만, 변수가 가진 주소를 어떻게 해석할지 아직 정하지 않았다는 의미다.
	// 따라서 void* 변수에 접근해 값을 건드는건 error다. 어느 크기를 어떻게 해석해야 할 지 알 수 없으니.

	// 그렇다면 &와 *는 어떻게 다를까?
	// 사실 asm으로 생성되는 코드에서는 동일하다고 한다.

	return 0;
}